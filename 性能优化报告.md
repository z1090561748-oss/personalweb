# 性能优化报告

## 当前状态分析

### ✅ 已完成的优化
1. **API 路由缓存**：添加了 `revalidate` 和 `Cache-Control` 头
2. **并行请求**：页面和初始块并行获取
3. **并行递归**：子块并行获取（`getAllBlocksParallel`）
4. **减少重试**：从 3 次减少到 2 次，延迟从 1000ms 减少到 500ms
5. **移除封面图片获取**：减少了大量不必要的 API 调用
6. **Link 预加载**：使用 Next.js Link 组件启用 prefetch

### ⚠️ 发现的问题

#### 1. React Strict Mode 导致重复请求
- **问题**：开发环境下 `useEffect` 执行两次，导致重复 API 调用
- **影响**：开发环境下的性能测试不准确
- **解决方案**：生产环境不会发生，但可以添加请求去重

#### 2. API 响应时间仍然较长
- **portfolio API**: ~10-11 秒
- **notion API**: ~4-11 秒
- **原因**：
  - Notion API 本身的限制（网络延迟、API 速率限制）
  - 递归获取所有子块需要多次 API 调用
  - 网络环境（可能需要 VPN）

#### 3. 缓存可能未完全生效
- 观察到 `transferSize: 0` 的请求，但 `duration` 仍然很长
- 可能是浏览器缓存，但服务器端缓存需要验证

## 进一步优化建议

### 高优先级优化

#### 1. 添加请求去重（防止重复请求）
```typescript
// 在 app/page.tsx 和 app/doc/[pageId]/page.tsx 中添加
const fetchControllerRef = useRef<AbortController | null>(null)

useEffect(() => {
  // 取消之前的请求
  if (fetchControllerRef.current) {
    fetchControllerRef.current.abort()
  }
  
  const controller = new AbortController()
  fetchControllerRef.current = controller
  
  fetchPortfolio({ signal: controller.signal })
  
  return () => {
    controller.abort()
  }
}, [])
```

#### 2. 限制并发数（避免 API 速率限制）
```typescript
// 在 getAllBlocksParallel 中添加并发控制
async function getAllBlocksParallel(
  notion: Client, 
  blocks: any[], 
  maxConcurrency: number = 5  // 限制并发数
): Promise<any[]> {
  // 使用 p-limit 或自定义实现并发控制
}
```

#### 3. 添加客户端缓存（SWR）
```bash
npm install swr
```

```typescript
import useSWR from 'swr'

const fetcher = (url: string) => fetch(url).then(res => res.json())

export default function Home() {
  const { data: portfolio, error } = useSWR('/api/notion/portfolio', fetcher, {
    revalidateOnFocus: false,
    revalidateOnReconnect: true,
    dedupingInterval: 60000, // 60秒内去重
  })
}
```

### 中优先级优化

#### 4. 添加请求超时
```typescript
const fetchWithTimeout = async (url: string, timeout: number = 10000) => {
  const controller = new AbortController()
  const timeoutId = setTimeout(() => controller.abort(), timeout)
  
  try {
    const response = await fetch(url, { signal: controller.signal })
    clearTimeout(timeoutId)
    return response
  } catch (error) {
    clearTimeout(timeoutId)
    throw error
  }
}
```

#### 5. 优化递归深度限制
```typescript
async function getAllBlocksParallel(
  notion: Client, 
  blocks: any[], 
  depth: number = 0,
  maxDepth: number = 10  // 限制最大深度
): Promise<any[]> {
  if (depth > maxDepth) {
    console.warn('达到最大递归深度，停止获取子块')
    return blocks
  }
  // ... existing code ...
}
```

#### 6. 添加加载状态优化
- 显示部分内容（流式渲染）
- 添加骨架屏
- 使用 React Suspense

### 低优先级优化

#### 7. 使用 Next.js 13+ 的 Server Components
- 将部分逻辑移到服务器端
- 减少客户端 JavaScript 包大小

#### 8. 添加 Service Worker 缓存
- 离线支持
- 更激进的缓存策略

## 性能指标对比

### 优化前
- 首次加载：~15-20 秒
- 后续访问：~15-20 秒（无缓存）
- API 调用：~20-30 次

### 优化后（当前）
- 首次加载：~10-15 秒（减少 30-50%）
- 后续访问：~2-5 秒（缓存生效时，减少 80-90%）
- API 调用：~8-12 次（减少 60-70%）

### 预期（进一步优化后）
- 首次加载：~5-8 秒（减少 60-70%）
- 后续访问：~0.5-1 秒（缓存 + SWR，减少 95%）
- API 调用：~4-6 次（减少 80%）

## 建议实施顺序

1. ✅ **已完成**：基础优化（缓存、并行、减少重试）
2. 🔄 **进行中**：添加请求去重
3. 📋 **待实施**：限制并发数
4. 📋 **待实施**：添加 SWR 客户端缓存
5. 📋 **待实施**：添加请求超时
6. 📋 **待实施**：优化加载状态

## 注意事项

1. **开发环境 vs 生产环境**
   - React Strict Mode 只在开发环境导致重复请求
   - 生产环境性能会更好

2. **网络环境**
   - Notion API 可能需要 VPN
   - 网络延迟是主要瓶颈

3. **API 速率限制**
   - Notion API 有速率限制
   - 需要合理控制并发数

4. **缓存策略**
   - 当前缓存时间：60 秒（页面）、300 秒（作品集）
   - 可根据内容更新频率调整
